Pipeline Cookbook
=================
The heuristics adopted in the pipeline appear to work well in the majority of
cases, but there are invariably cases not adequately treated by the defaults
and thus require custom processing. To aid in the processing of a FAUST target,
the pipeline provides helper classes that abstract away the book-keeping aspects
into individual tasks to be configured depending on the requirements of a
particular field and SPW.

Note that because the pipeline is computationally intensive, even imaging
a single SPW can take a day or more when CASA is run using single threaded
execution, and still a substantial amount of time when executed in parallel.


Running the default pipeline
----------------------------
The :class:`faust_imaging.ImageConfig` class provides the primary interface to
``tclean`` within CASA and encapsulates properties specific to a field, SPW,
array configuration, and desired ``tclean`` parameters. Please refer to the
:doc:`API Documentation <faust_imaging>` and the docstring for additional
information on the calling convention of this class.

To run all tasks of the pipeline with default parameters, first create an
instance of the :class:`faust_imaging.ImageConfig` class and use the
:meth:`faust_imaging.ImageConfig.run_pipeline` method.

.. code-block:: python

   config = ImageConfig.from_name('CB68', '244.936GHz_CS', weighting=0.5)
   config.run_pipeline()

The full list of SPW labels may be found in the `ALL_SPW_LABELS` variable.
The above command will generate the default pipeline image products for
the target field CB68, for the CS (5-4) line of Setup 2, using a Briggs
robust factor of ``0.5``. The full calling convention is:

.. code-block:: python

   ImageConfig.from_name(
           '<FIELD>',  # field name, e.g., "CB68". See the global var `ALL_FIELDS`
           '<LABEL>',  # SPW label, e.g., "244.936GHz_CS"
           weighting=0.5,
           # ^ Use a number for Briggs robust or a string recognized by tclean,
           # e.g., 'uniform' or 'natural'. The default is 0.5.
           fullcube=True,
           # ^ Image the full bandwidth of the SPW or a narrow 20km/s window
           # centered on the primary line of interest. The default is True.
           kind='joint',
           # ^ What combination of array configurations to use. Possible values
           # include ('joint', '12m', '7m'). The default is 'joint'.
   )


Pipeline task description
-------------------------
The :meth:`faust_imaging.ImageConfig.run_pipeline` method discussed above is
primarily a wrapper for calling all of the pipeline tasks in sequence using the
default parameters. For custom imaging, it is recommended that users create a
recipe using the underlying tasks.  As an example, this is the code that is
executed by default:

.. code-block:: python

   config = ImageConfig.from_name(...)
   ext = 'clean'  # extensionn name for final cleaned products
   config.make_dirty_cube()
   config.clean_line_nomask(sigma=4.5)
   config.make_seed_mask(sigma=5.0)
   config.clean_line(mask_method='seed+multithresh', ext=ext)
   config.postprocess(ext=ext, make_fits=True)

The following sections describe the function of each pipeline step in detail.
The start of each sub-section includes a link to the API documentation where
a detailed description of the parameters may be found.

``make_dirty_cube``: Creating the dirty cube
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.make_dirty_cube`. A call to ``tclean`` is
first made with ``niter=0`` to grid and transform the data. These data
products have the default extension name of "dirty" which may be changed
by modifying the global variable ``DIRTY_EXT``. The dirty image products
are used for computing the RMS and computing the common frequency coverage
between different array configurations.

``clean_line_nomask``: Initial un-masked cleaning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.clean_line_nomask`. The "auto-multithresh"
method for automated clean mask generation in ``tclean`` determines noise
characterstics per-plane, along with other heuristics based on the maximum
negative residual, which can make cleaning extended emission where substantial
filtering present problematic. For this reason an initial deconvolution is
performed without masking to a relatively shallow depth set by the parameter
``sigma`` with a default value of 4.5 times the RMS.  Files are generated using
the default extension name "nomask" which can be set using the globa variable
``NOMSK_EXT``. To avoid diverging in the unrestricted clean, large angular
scales may be excluded from multiscale clean using the ``scale_upper_limit``
parameter.

``make_seed_mask``: Creating the threshold mask
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.make_seed_mask`. A threshold is applied to
the restored image generated by ``clean_line_nomask`` to create an initial
input mask to "seed" the mask created with auto-multithresh. This ensures
that all channels, even those with strong spatial filtering, are masked.
The threshold to apply may be set with the ``sigma`` parameter; the
default is 5.0 times the RMS.

``clean_line``: Second, masked cleaning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.clean_line`. A second, new round of
deconvolution is performed using the thresholded mask generated in the
previous steps as a "seed" for auto-multithresh. This combination of the seed
mask and auto-multithresh is the recommended method and is the default masking
method, and set as the default through the parameter
``mask_method="seed+multithresh"``.  If ``mask_method="auto-multithresh"`` is
used then the prior two pipeline steps used to generate the "seed" mask are not
required.  The global clean threshold can be set with the ``sigma`` parameter.
The parameter ``ext`` sets the string appended to the filename. The standard
convention is to use "clean" for these final products, but other names may be
used when experimenting with different parameters to avoid over-writing
existing runs.

Runs can be restarted and cleaned interactively using the ``restart`` and
``interactive`` keyword arguments. See `Restarting`_ for further detail.

``postprocess``: Image cube postprocessing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.postprocess`. Lastly, a few minor post
processing steps are applied to the image products generated by ``clean_line``.
These include (1) checking whether the maximum value of the residual image
exceeds 5.5-sigma, (2) correcting the restored image for the primary beam
attenuation, (3) smoothing the image to a common-beam angular resolution, and
(4) exporting the CASA image to a FITS image. The final FITS image names will
be of the form:

.. code-block:: none

   # template form:
   <PROD_DIR>/<FIELD>/<FIELD>_<LABEL>_<KIND>_<WEIGHT>_<EXT>.image.pbcor.common.fits
   # example:
   images/CB68/CB68_244.936GHz_CS_joint_0.5_clean.image.pbcor.common.fits

As an optional final step, quality assurance (QA) plots can be generated
with the function :func:`faust_imaging.make_all_qa_plots`. This function will
create channel maps of all restored images and residual images for a field
where the peak restored image intensity exceeds 6-sigma. These plots are
useful for assessing whether further deconvolution is required.

.. code-block:: python

   make_all_qa_plots('CB68', ext='clean')
   # PDF/PNG files will be written to <PLOT_DIR> (default "<PROD_DIR>/plots")


Imaging cut-out velocity windows
--------------------------------
The default pipeline setting of ``fullcube=True`` will image the entire
bandwidth of the SPW. These can be rather large, typically more than 470
channels or 90 km/s. If only a particular line is of interest, then
a cut-out in frequency may be imaged to reduce run-time cost and disk
space requirements.

If the line to be imaged was the primary target of the SPW, then no changes
need to be made, e.g., Setup 1 C18O J=2-1 near 219.56 GHz. The default
velocity bandwidth is 20 km/s (+/- 10 km/s about the system velocity) but may
be set with the global parameter ``LINE_VWIN`` parameter.

.. code-block:: python

   LINE_VWIN = '5km/s'
   config = ImageConfig.from_name(..., fullcube=False)
   config.run_pipeline()

The primary target of the SPW can be determined by comparing the value of
``spw.mol_name`` (primary molecule) to ``spw.name`` (full SPW name with
transitions from the correlator configuration).

Imaging cut-outs that were not the primary targets of an SPW requires creating
a new :class:`faust_imaging.Spw` instance.

.. code-block:: python

   dset = DataSet('CB68', kind='joint')
   # define a 5km/s window for +/- 2.5 km/s about the system velocity
   LINE_VWIN = '5km/s'
   # We wish to image the acetaldehyde CH3CHO 11(1,10)-10(1,9) transition
   # also found in the Setup 1 SPW ID 27. The primary targeted line was
   # deuterated ammonia NH2D 3(2,2)s-3(2,1)a. Create a copy of this window
   # and change the molecule name (for files and paths) and the line
   # rest frequency of the new transition.
   spw = ALL_SPWS['216.563GHz_NH2D'].copy()
   spw.mol_name = 'CH3CHO'
   spw.restfreq = '216.58193040GHz'  # SLAIM
   # Initialize the `ImageConfig` class directly from the instances and
   # run the pipeline.
   config = ImageConfig(dset, spw, fullcube=False)
   config.run_pipeline(ext='5kms_clean')
   # The final image products will be named as:
   #   CB68_216.582GHz_CH3CHO_joint_0.5_5kms_clean.*


.. _Restarting:

Restarting ``tclean`` and manual masking
----------------------------------------
Some datasets can be difficult to clean satisfactorily with the default
pipeline settings, particularly those with extended emission that suffers
heavy spatial filtering (ex. C180, c-C3H2). Good results on these cubes
may require manual intervention in the defining the clean masks. After
inspecting the results of the pipeline products, a run can be restarted using
the same settings but using the ``restart`` and ``interactive`` keyword
arguments:

.. code-block:: python

   config = ImageConfig(...)
   # The pipeline has already been run previously and there exist images with
   # names ending in the extension "clean". Now restart the imaging using
   # the existing files and running in interactive mode. It's probably
   # a good idea to backup the `.model` and `.mask` files in the event
   # the deconvolution fairs poorly.
   config.clean_line_interactive_restart(ext='clean')
   # The above command is equivalent to:
   #   config.clean_line(ext='clean', restart=True, interactive=True)
   # If the results are satisfactory, apply the post-processing steps
   # to finish the pipeline.
   config.postprocess(ext='clean')

The above commands will pull up the CASA interactive viewer for creating the
clean masks manually. It is recommended to set the ``cycleniter`` in the upper
left to a low value, perhaps 100 iterations, and to use the green "recycling"
arrow to execute a few iterations. The un-cleaned emission of interest is often
present in channels with extended emission near the edge of the primary beam
mask.  These channels have a high-probability of diverging if left to finish
the run using the blue "right arrow". Once the extended emission appears to
have been cleaned satisfactorily, finish the run by clicking the red "stop
sign" button.


Parallel image processing
-------------------------
The computational efficiency for imaging a single SPW can be improved by
a factor of approximately two using CASA run with MPI (i.e., ``mpicasa``).
The pipeline script will automatically recognize from the environment whether
it is being run with ``mpicasa`` and use ``parallel=True`` accordingly in
``tclean``. At the current time the preferred pipeline masking method of
``mask_method='seed+multithresh'`` is not currently supported in parallel.
Imaging may be run in parallel when using ``mask_method='auto-multithresh'``,
although the former method is preferred.

The majority of the computational run-time cost of the imaging derives from
the conservative ``cyclefactor`` and ``gain`` used with ``tclean``. These
parameters are selected to avoid divergences that are common when cleaning
extended emission with large scales using multiscale clean and clean
boxing/masking. If the emission is relatively compact in the field and
SPW of interest, these parameters can be relaxed to increase performance:

.. code-block:: python

   config.gain = 0.1         # default 0.05
   config.cyclefactor = 1.0  # default 2.0
   config.run_pipeline()


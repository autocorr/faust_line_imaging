Pipeline Cookbook
=================
The heuristics adopted in the pipeline appear to work well in the majority of
cases, but there are invariably cases not adequately treated by the defaults
and thus require custom processing. To aid in the processing of a FAUST target,
the pipeline provides helper classes that abstract away the book-keeping aspects
into individual tasks to be configured depending on the requirements of a
particular field and SPW.

Note that because the pipeline is computationally intensive, even imaging
a single SPW can take a day or more when CASA is run using single threaded
execution, and still a substantial amount of time when executed in parallel.


Running the default pipeline
----------------------------
The :class:`faust_imaging.ImageConfig` class provides the primary interface to
``tclean`` within CASA and encapsulates properties specific to a field, SPW,
array configuration, and desired ``tclean`` parameters. Please refer to the
:doc:`API Documentation <faust_imaging>` and the docstring for additional
information on the calling convention of this class.

To run all tasks of the pipeline with default parameters, first create an
instance of the :class:`faust_imaging.ImageConfig` class and use the
:meth:`faust_imaging.ImageConfig.run_pipeline` method.

.. code-block:: python

   config = ImageConfig.from_name('CB68', '244.936GHz_CS', weighting=0.5)
   config.run_pipeline()

The full list of SPW labels may be found in the `ALL_SPW_LABELS` variable.
The above command will generate the default pipeline image products for
the target field CB68, for the CS (5-4) line of Setup 2, using a Briggs
robust factor of ``0.5``. The full calling convention is:

.. code-block:: python

   ImageConfig.from_name(
           '<FIELD>',  # field name, e.g., "CB68". See the global var `ALL_FIELDS`
           '<LABEL>',  # SPW label, e.g., "244.936GHz_CS"
           weighting=0.5,
           # ^ Use a number for Briggs robust or a string recognized by tclean,
           # e.g., 'uniform' or 'natural'. The default is 0.5.
           fullcube=True,
           # ^ Image the full bandwidth of the SPW or a narrow 20km/s window
           # centered on the primary line of interest. The default is True.
           kind='joint',
           # ^ What combination of array configurations to use. Possible values
           # include ('joint', '12m', '7m'). The default is 'joint'.
   )


Pipeline task description
-------------------------
The :meth:`faust_imaging.ImageConfig.run_pipeline` method discussed above is
primarily a wrapper for calling all of the pipeline tasks in sequence using the
default parameters. For custom imaging, it is recommended that users create a
recipe using the underlying tasks.  As an example, this is the code that is
executed by default:

.. code-block:: python

   config = ImageConfig.from_name(...)
   ext = 'clean'  # extensionn name for final cleaned products
   config.make_dirty_cube()
   config.clean_line_nomask(sigma=4.5)
   config.make_seed_mask(sigma=5.0)
   config.clean_line(mask_method='seed+multithresh', ext=ext)
   config.postprocess(ext=ext, make_fits=True)

The following sections describe the function of each pipeline step in detail.
The start of each sub-section includes a link to the API documentation where
a detailed description of the parameters may be found.

``make_dirty_cube``: Creating the dirty cube
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.make_dirty_cube`. A call to ``tclean`` is
first made with ``niter=0`` to grid and transform the data. These data
products have the default extension name of "dirty" which may be changed
by modifying the global variable ``DIRTY_EXT``. The dirty image products
are used for computing the RMS and computing the common frequency coverage
between different array configurations.

``clean_line_nomask``: Initial un-masked cleaning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.clean_line_nomask`. The "auto-multithresh"
method for automated clean mask generation in ``tclean`` determines noise
characterstics per-plane, along with other heuristics based on the maximum
negative residual, which can make cleaning extended emission where substantial
filtering present problematic. For this reason an initial deconvolution is
performed without masking to a relatively shallow depth set by the parameter
``sigma`` with a default value of 4.5 times the RMS.  Files are generated using
the default extension name "nomask" which can be set using the globa variable
``NOMSK_EXT``. To avoid diverging in the unrestricted clean, large angular
scales may be excluded from multiscale clean using the ``scale_upper_limit``
parameter.

``make_seed_mask``: Creating the threshold mask
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.make_seed_mask`. A threshold is applied to
the restored image generated by ``clean_line_nomask`` to create an initial
input mask to "seed" the mask created with auto-multithresh. This ensures
that all channels, even those with strong spatial filtering, are masked.
The threshold to apply may be set with the ``sigma`` parameter; the
default is 5.0 times the RMS.

``clean_line``: Second, masked cleaning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.clean_line`. A second, new round of
deconvolution is performed using the thresholded mask generated in the
previous steps as a "seed" for auto-multithresh. This combination of the seed
mask and auto-multithresh is the recommended method and is the default masking
method, and set as the default through the parameter
``mask_method="seed+multithresh"``.  If ``mask_method="auto-multithresh"`` is
used then the prior two pipeline steps used to generate the "seed" mask are not
required.  The global clean threshold can be set with the ``sigma`` parameter.
The parameter ``ext`` sets the string appended to the filename. The standard
convention is to use "clean" for these final products, but other names may be
used when experimenting with different parameters to avoid over-writing
existing runs.

Runs can be restarted and cleaned interactively using the ``restart`` and
``interactive`` keyword arguments. See `Restarting`_ for further detail.

``postprocess``: Image cube postprocessing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:meth:`faust_imaging.ImageConfig.postprocess`. Lastly, a few minor post
processing steps are applied to the image products generated by ``clean_line``.
These include (1) checking whether the maximum value of the residual image
exceeds 5.5-sigma, (2) correcting the restored image for the primary beam
attenuation, (3) smoothing the image to a common-beam angular resolution, and
(4) exporting the CASA image to a FITS image. The final FITS image names will
be of the form:

.. code-block:: none

   # template form:
   <PROD_DIR>/<FIELD>/<FIELD>_<LABEL>_<KIND>_<WEIGHT>_<EXT>.image.pbcor.common.fits
   # example:
   images/CB68/CB68_244.936GHz_CS_joint_0.5_clean.image.pbcor.common.fits

As an optional final step, quality assurance plots can be generated.
These plots are useful for assessing whether further deconvolution is required.
Making these plots is described in `QA Plots`_.


.. _QA Plots:

Quality assurance plots
-----------------------
Quality Assurance (QA) plots are useful for quickly obtaining an overview of
whether the deconvolved products are satisfactory. The function
:func:`faust_imaging.make_all_qa_plots` can be used to generate channel maps of
all restored images and residual images for a field where the peak restored
image intensity exceeds 6-sigma. PDF and PNG files are written to the directory
specified in ``PLOT_DIR`` (by default ``<PROD_DIR>/plots``).

.. code-block:: python

   # to overwrite all existing plots, use the default overwrite=True
   make_all_qa_plots('CB68', ext='clean')

   # to skip plots that have already been made, set overwrite=False
   make_all_qa_plots('CB68', ext='clean', overwrite=False)

To make an individual QA plot from an image path name use
:func:`faust_imaging.make_qa_plots_from_image`:

.. code-block:: python

   # example filename for CB68 CS (5-4)
   imagename = 'images/CB68/CB68_244.936GHz_CS_joint_0.5_clean.image'
   make_qa_plots_from_image(imagename)

For developing custom plotting routines, the :class:`faust_imaging.CubeSet`
class may be of use.


Imaging cut-out velocity windows
--------------------------------
The default pipeline setting of ``fullcube=True`` will image the entire
bandwidth of the SPW. These can be rather large, typically more than 470
channels or 90 km/s. If only a particular line is of interest, then
a cut-out in frequency may be imaged to reduce run-time cost and disk
space requirements.

If the line to be imaged was the primary target of the SPW, then no changes
need to be made, e.g., Setup 1 C18O J=2-1 near 219.56 GHz. The default
velocity bandwidth is 20 km/s (+/- 10 km/s about the system velocity) but may
be set with the global parameter ``LINE_VWIN`` parameter.

.. code-block:: python

   LINE_VWIN = '5km/s'
   config = ImageConfig.from_name(..., fullcube=False)
   config.run_pipeline()

The primary target of the SPW can be determined by comparing the value of
``spw.mol_name`` (primary molecule) to ``spw.name`` (full SPW name with
transitions from the correlator configuration).

Imaging cut-outs that were not the primary targets of an SPW requires creating
new instances of the classes :class:`faust_imaging.Spw` and
:class:`faust_imaging.DataSet` in order to instantiate ``ImageConfig``
directly. This can be particularly useful for the continuum windows which
are resource intensive to process with full bandwidth cubes.

.. code-block:: python

   dset = DataSet('CB68', kind='joint')
   # define a 5km/s window for +/- 2.5 km/s about the system velocity
   LINE_VWIN = '5km/s'
   # We wish to image the acetaldehyde CH3CHO 11(1,10)-10(1,9) transition
   # also found in the Setup 1 SPW ID 27. The primary targeted line was
   # deuterated ammonia NH2D 3(2,2)s-3(2,1)a. Create a copy of this window
   # and change the molecule name (for files and paths) and the line
   # rest frequency of the new transition.
   spw = ALL_SPWS['216.563GHz_NH2D'].copy()
   spw.mol_name = 'CH3CHO'
   spw.restfreq = '216.58193040GHz'  # SLAIM
   # Initialize the `ImageConfig` class directly from the instances and
   # run the pipeline.
   config = ImageConfig(dset, spw, fullcube=False)
   config.run_pipeline(ext='5kms_clean')
   # The final image products will be named as:
   #   CB68_216.582GHz_CH3CHO_joint_0.5_5kms_clean.*


.. _Restarting:

Restarting ``tclean`` and manual masking
----------------------------------------
Some datasets can be difficult to clean satisfactorily with the default
pipeline settings, particularly those with extended emission that suffers
heavy spatial filtering (ex. C180, c-C3H2). Good results on these cubes
may require manual intervention in the defining the clean masks. After
inspecting the results of the pipeline products, a run can be restarted using
the same settings but using the ``restart`` and ``interactive`` keyword
arguments of :meth:`faust_imaging.ImageConfig.clean_line`:

.. code-block:: python

   config = ImageConfig(...)
   # The pipeline should already have been run previously and for this example
   # there should exist images with names ending in the extension "clean".

   # Now restart the deconvolution using the existing files and run it in
   # interactive mode. It's likely a good idea to backup the `.model` and
   # `.mask` files in the event the deconvolution fairs poorly. Also, if you
   # wish to clean more deeply, one can set the `sigma` argument to a lower
   # value here.
   config.clean_line(ext='clean', restart=True, interactive=True)
   # Note that an alias is included for this use, identical in arguments and
   # calling convention as above, named:
   #   config.clean_line_interactive_restart(ext='clean')
   # Now, if the results are satisfactory, apply the post-processing steps
   # to finish the pipeline.
   config.postprocess(ext='clean')

The above commands will pull up the CASA interactive viewer for creating the
clean masks manually. It is recommended to set the ``cycleniter`` in the upper
left to a low value, perhaps 100 iterations, and to use the green "recycling"
arrow to execute a few iterations. The un-cleaned emission of interest is often
present in channels with extended emission near the edge of the primary beam
mask.  These channels have a high-probability of diverging if left to finish
the run using the blue "right arrow". Once the extended emission appears to
have been cleaned satisfactorily, finish the run by clicking the red "stop
sign" button.

Restarting ``tclean`` can also be performed without using the interactive mode.
One example usage may be cleaning to a shallow depth, inspecting the results or
applying a few tweaks, and then cleaning more deeply.

.. code-block:: python

   config = ImageConfig(...)
   # ... pipeline has been run up to `.clean_line`
   # First, clean relatively shallowly to 3.5-sigma and let it run
   # automatically.
   config.clean_line(ext='clean', sigma=3.5)
   # Inspect the resulting cubes to see if the results are satisfactory. The
   # QA plots could be made for the target, for example.
   # Now, continue the deconvolution to a lower depth of 2.0-sigma
   config.clean_line(ext='clean', restart=True, sigma=2.0)
   config.postprocess(ext='clean')


Parallel image processing
-------------------------
The computational efficiency for imaging a single SPW can be improved by
a factor of approximately two using CASA run with MPI (i.e., ``mpicasa``).
The pipeline script will automatically recognize from the environment whether
it is being run with ``mpicasa`` and use ``parallel=True`` accordingly in
``tclean``. At the current time the preferred pipeline masking method of
``mask_method='seed+multithresh'`` is not currently supported in parallel.
Imaging may be run in parallel when using ``mask_method='auto-multithresh'``,
although the former method is preferred.

The majority of the computational run-time cost of the imaging derives from
the conservative ``cyclefactor`` and ``gain`` used with ``tclean``. These
parameters are selected to avoid divergences that are common when cleaning
extended emission with large scales using multiscale clean and clean
boxing/masking. If the emission is relatively compact in the field and
SPW of interest, these parameters can be relaxed to increase performance:

.. code-block:: python

   config.gain = 0.1         # default 0.05
   config.cyclefactor = 1.0  # default 2.0
   config.run_pipeline()


Creating moment maps
--------------------
Moment maps and other point estimators (e.g., maximum) may be generated
from the data using the :func:`faust_imaging.make_all_moment_maps` function for
all of the SPWs of a target or :func:`faust_imaging.make_moments_from_image`
for a single SPW of a target.

.. code-block:: python

   # Create moment maps for all SPWs. The `vwin` parameter sets the velocity
   # window half-width in km/s to calculate the moment over.
   make_all_moment_maps('CB68', ext='clean', vwin=5)
   # Generate a single set of moment maps
   imagename = 'images/CB68/CB68_244.936GHz_CS_joint_0.5_clean.image'
   make_moments_from_image(imagename, vwin=5)

The moments are calculated by masking pixels which are not (a) in the clean
mask and (b) do not meet a significance cut on a Hanning smoothed cube. The
moments are computed using the unsmoothed data.


.. _Chunking:

Frequency-chunked image processing
----------------------------------
The memory requirements for imaging the full spectral windows using the
``fullcube=True`` are demanding, requiring several hundred gigabytes of RAM.
To relieve memory requirements, the pipeline may be run on individual
frequency intervals or "chunks". To run the standard pipeline on each
chunk and then concatenate the results, use the helper method
:meth:`faust_imaging.ImageConfig.run_pipeline_chunked`:

.. code-block:: python

   config = ImageConfig(...)  # or `.from_name(...)`
   config.run_pipeline_chunked(ext='clean', nchunks=4)

The chunked configs may also be created from a normal instance using
:meth:`faust_imaging.ImageConfig.duplicate_into_chunks` and treated
individually for more customized processing.

.. code-block:: python

   # Initialize an image configuration instance with the desired properties.
   full_config = ImageConfig(...)
   # Create 4 chunks with properties inherited from the above, full instance.
   # Note that if a ".sumwt" file does not exist, a dirty image will be
   # made of a small field in order to calculate it first.
   chunked_configs = full_config.duplicate_into_chunks(nchunks=4)
   # Standard pipeline processing may now proceed on each chunked config.
   for config in chunked_configs:
        config.run_pipeline(ext='clean')
   # Concatenate the final cube products into contiguous versions.
   concat_chunked_cubes(chunked_configs, ext='clean')

By default most important image extensions (e.g., '.image', etc.) are concatenated
by :func:`faust_imaging.concat_chunked_cubes`. Extensions may also be specified
by the keyword argument ``im_exts``, e.g. ``im_exts=('image', 'model')``.

Note that while in principle running ``tclean`` with the parameter
``chankchunks=-1`` applies a similar serial processing of frequency ranges,
unfortunately problems persist.  The most serious issues observed are that the
final concatentation step in ``tclean`` can segfault, and that copying the
internal mask files using ``makemask`` also frequently fails for large image
cubes.

The pipeline procedures may also be run in different instances in CASA to
process parts of the image in parallel. To do so, simply ensure that the
same configuration options are applied in order to reproduce the equivalent
``ImageConfig`` instances, as below:

.. code-block:: python

   # In CASA instance 1, process chunks 0 and 1
   full_config = ImageConfig(...)
   chunked_configs = full_config.duplicate_into_chunks(nchunks=4)
   for config in chunked_configs[:2]:
       config.run_pipeline(ext='clean')

   # In CASA instance 2, process chunks 2 and 3. Ensure that the same
   # configuration options and modifications are also applied here as well!
   full_config = ImageConfig(...)
   chunked_configs = full_config.duplicate_into_chunks(nchunks=4)
   for config in chunked_configs[2:]:
       config.run_pipeline(ext='clean')

   # Now, in any CASA instance after the above two have finished running,
   # merge the image products.
   full_config = ImageConfig(...)
   chunked_configs = full_config.duplicate_into_chunks(nchunks=4)
   concat_chunked_cubes(chunked_configs, ext='clean')


.. _SetRms:

Manually setting the RMS
------------------------
By default the global RMS used for deriving thresholds is computed from the
full dirty cube. For small windows where >50% of the channels may contain
significant emission, this globally RMS value may not be appropriate. If
the desired RMS value to use is known, the
:attr:`faust_imaging.ImageConfig.rms` attribute may be set manually.

.. code-block:: python

   config = ImageConfig(...)
   config.rms = 0.001  # in Jy


Imaging Setup 3 SPWs with small chunk sizes
-------------------------------------------
Due to the large field-of-view, small beam size, and large number of channels,
imaging the Setup 3 SPWs poses a formidable data processing challenge (typical
image dimensions of 3500x3500x1000). Individual Setup 3 cubes can also be about
10 to 40 times larger in file size (~40 to 200 GB for a single cube) which can
cause significant issues in CASA usinng machines even with 500 GB RAM.

To effectively process these the Setup 3 SPWs, processing in small frequency
interval "chunks" is required (see `Chunking`_).  Chunked images of only ~10
channels however may report biased image RMS values if emission is present
over most channels (see `SetRms`_). Written below is a recipe for creating a
few dirty cubes, calculating their RMS values, and then using that RMS value
for all chunks.

.. code-block:: python

   # First calculate the frequency intervals of the chunks. For N2H+ with ~950
   # channels and 100 chunks, a typical chunked image has 9 channels.
   full_config = ImageConfig.from_name('CB68', '93.181GHz_N2Hp')
   chunked_configs = full_config.duplicate_into_chunks(nchunks=100)
   # Create dirty cubes and check the RMS values at the low-end, middle, and
   # high-end of the band. The little helper function below is only for
   # brevity. Note that the computing the RMS at the middle of the band is
   # safe for N2H+ since the band center frequency is offset! This is not
   # always the case.
   def get_chunk_rms(config):
       config.make_dirty_cube()
       return config.rms
   lo_rms = get_chunk_rms(chunked_configs[ 2])
   md_rms = get_chunk_rms(chunked_configs[49])
   hi_rms = get_chunk_rms(chunked_configs[97])
   # Check the RMS values here to see that they are pretty similar, if within
   # ~10%, then it is reasonable to simply set it for all chunks.

   # Now remake the config and run all chunks. By setting the RMS of the
   # prototype instance it is propagated to all of the duplicate instances.
   full_config = ImageConfig.from_name('CB68', '93.181GHz_N2Hp')
   full_config.rms = md_rms  # or whatever
   chunked_configs = full_config.duplicate_into_chunks(nchunks=100)
   for config in chunked_configs:
       config.run_pipeline()
   concat_chunked_cubes(chunked_configs, ext='clean')

Ozone lines are present near several SPWs that raise the RMS values appreciably
(>30%) close to the band edge (e.g., "231.221GHz_13CS" and "231.322GHz_N2Dp").
For these SPWs setting a uniform RMS is not appropriate. It is straight
forward however to increase the RMS for certain chunks or even set the value
for each chunk individually using an interpolation function.

.. code-block:: python

   # Set the top 15 chunks (85-99) to have double the RMS.
   rms = 0.003
   full_config = ImageConfig.from_name('CB68', '93.181GHz_N2Hp')
   full_config.rms = rms
   chunked_configs = full_config.duplicate_into_chunks(nchunks=100)
   for config in chunked_configs:
       if config.chunk.index > 84:
           config.rms = 2 * rms
       config.run_pipeline()


